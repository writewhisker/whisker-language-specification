# Stage 2.10: TypeScript - Runtime Once-Only and Inline Conditionals

## Objective
Implement once-only tracking and inline conditional evaluation.

## Files to Modify
- `packages/story-player/src/StoryPlayer.ts`
- `packages/story-player/src/types.ts`

## Prompt

```
Update the TypeScript runtime for once-only and inline conditionals:

1. Update packages/story-player/src/types.ts:

export interface RuntimeState {
  // ... existing fields
  seenOnce: Set<string>;  // Tracks seen once blocks by ID
}

// For save/load
export interface SaveData {
  // ... existing fields
  seenOnce: string[];
}

2. Update StoryPlayer.ts for once-only blocks:

private processOnceBlock(node: OnceBlockNode): void {
  const onceId = `${this.state.currentPassage}:${node.id}`;

  if (!this.state.seenOnce.has(onceId)) {
    // First time - show content and mark as seen
    this.state.seenOnce.add(onceId);
    this.processContent(node.content);
  }
  // Otherwise skip the content
}

// API to reset once blocks
public resetOnce(passage?: string): void {
  if (passage) {
    // Reset only blocks in specific passage
    for (const id of this.state.seenOnce) {
      if (id.startsWith(`${passage}:`)) {
        this.state.seenOnce.delete(id);
      }
    }
  } else {
    // Reset all
    this.state.seenOnce.clear();
  }
}

3. Implement inline conditional evaluation:

private evaluateInlineConditional(node: InlineConditionalNode): string {
  const conditionResult = this.evaluateExpression(node.condition);

  if (conditionResult) {
    return this.renderInlineContent(node.trueContent);
  } else {
    return this.renderInlineContent(node.falseContent);
  }
}

private renderInlineContent(content: ContentNode[]): string {
  let result = '';
  for (const node of content) {
    if (node.type === 'text') {
      result += node.value;
    } else if (node.type === 'inline_conditional') {
      result += this.evaluateInlineConditional(node);
    } else if (node.type === 'variable_interpolation') {
      result += this.getVariable(node.name);
    }
  }
  return result;
}

4. Create tests:

describe('Once-Only Blocks', () => {
  it('shows content only once', () => {
    const player = createPlayer(\`
:: Start
{once}
First time!
{/once}
Always here.
+ [Again] -> Start
\`);

    let output = player.getOutput();
    expect(output).toContain('First time!');
    expect(output).toContain('Always here.');

    player.choose(0);  // Go back to Start
    output = player.getOutput();
    expect(output).not.toContain('First time!');
    expect(output).toContain('Always here.');
  });

  it('persists across save/load', () => {
    const player = createPlayer(\`:: Start\n{once}Once{/once}\`);
    player.run();
    const save = player.save();

    const player2 = createPlayer(\`:: Start\n{once}Once{/once}\`);
    player2.load(save);
    player2.navigateToPassage('Start');
    expect(player2.getOutput()).not.toContain('Once');
  });
});

describe('Inline Conditionals', () => {
  it('evaluates true branch', () => {
    const player = createPlayer(\`
:: Start
{do $gold = 150}
You have {$gold > 100 ? plenty of | few} coins.
\`);

    expect(player.getOutput()).toContain('plenty of');
  });

  it('evaluates false branch', () => {
    const player = createPlayer(\`
:: Start
{do $gold = 50}
You have {$gold > 100 ? plenty of | few} coins.
\`);

    expect(player.getOutput()).toContain('few');
  });
});
```

## Expected Output
~80 lines runtime + ~80 lines tests.

## Verification
```bash
pnpm --filter @writewhisker/story-player test -- --run once
pnpm --filter @writewhisker/story-player test -- --run inline
```

## Next Stage
2.11-lua-parser-flow.md
