# Stage 2.02: Specification - Tunnels

## Objective
Add tunnel syntax and semantics to the flow control specification.

## Files to Modify
- `phase-1-specification/spec/02-FLOW-CONTROL.md`

## Prompt

```
Update the flow control specification to add Tunnels section:

## Tunnels

Tunnels are subroutine-like passage calls that return to the calling location.

### Syntax

Call a tunnel:
```whisker
-> PassageName ->
```

Return from tunnel:
```whisker
->->
```

### Example

```whisker
:: Main
Before the aside.
-> Aside ->
After the aside.
+ [Continue] -> Next

:: Aside
This is a brief tangent.
->->
```

Execution:
1. "Before the aside." displays
2. Tunnel to Aside
3. "This is a brief tangent." displays
4. Return (->->)
5. "After the aside." displays
6. Choice presented

### Call Stack

Tunnels maintain a call stack:
- Each `-> X ->` pushes current location
- Each `->->` pops and returns
- Stack overflow at depth 100 (configurable)

### Nested Tunnels

```whisker
:: Main
-> A ->
Done.

:: A
In A.
-> B ->
Back in A.
->->

:: B
In B.
->->
```

Output: "In A." "In B." "Back in A." "Done."

### Tunnels with Choices

Choices in tunnels work normally:

```whisker
:: Main
-> Question ->
You answered.

:: Question
What is 2+2?
+ [3] Wrong! ->->
+ [4] Correct! ->->
+ [5] Wrong! ->->
```

### Rules

1. `->->` must be in a tunnel - error otherwise
2. Tunnel target must exist - error if not
3. Tunnel can call same passage (recursion allowed with depth limit)
4. State changes in tunnel persist after return

### Edge Cases

- Return from choice: `+ [OK] ->->` is valid
- Multiple returns: each path needs `->->`
- Tunnel to END: terminates story (doesn't return)
- Empty tunnel: `:: Empty\n->->` immediately returns
```

## Expected Output
~120 lines added to specification.

## Verification
```bash
grep -c "tunnel\|->->" phase-1-specification/spec/02-FLOW-CONTROL.md
# Expected: 25+
```

## Next Stage
2.03-spec-inline-conditionals.md
