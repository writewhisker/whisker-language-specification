# Stage 2.09: TypeScript - Runtime Tunnels

## Objective
Implement tunnel call stack in TypeScript runtime.

## Files to Modify
- `packages/story-player/src/StoryPlayer.ts`
- `packages/story-player/src/types.ts`

## Prompt

```
Update the TypeScript runtime to support tunnels:

1. Update packages/story-player/src/types.ts:

export interface CallFrame {
  passage: string;
  contentIndex: number;  // Where to resume
  localVariables: Map<string, unknown>;
}

export interface RuntimeState {
  // ... existing fields
  callStack: CallFrame[];
  maxCallDepth: number;  // Default: 100
}

2. Update packages/story-player/src/StoryPlayer.ts:

private processTunnelCall(node: TunnelCallNode): void {
  // Check stack depth
  if (this.state.callStack.length >= this.state.maxCallDepth) {
    throw new RuntimeError(
      `Call stack overflow: exceeded ${this.state.maxCallDepth} tunnel calls`
    );
  }

  // Push return frame
  this.state.callStack.push({
    passage: this.state.currentPassage,
    contentIndex: this.state.contentIndex + 1,
    localVariables: new Map(this.state.localVariables)
  });

  // Navigate to tunnel target
  this.navigateToPassage(node.target);
}

private processTunnelReturn(): void {
  if (this.state.callStack.length === 0) {
    throw new RuntimeError('Tunnel return (->->) without tunnel call');
  }

  // Pop frame
  const frame = this.state.callStack.pop()!;

  // Restore state
  this.state.currentPassage = frame.passage;
  this.state.contentIndex = frame.contentIndex;

  // Continue processing from return point
  this.continueFromIndex();
}

// Update choice handling to support tunnel return in choice
private processChoiceAction(choice: ChoiceNode): void {
  if (choice.action?.type === 'tunnel_return') {
    this.processTunnelReturn();
  } else if (choice.target) {
    this.navigateToPassage(choice.target);
  }
}

3. Create tests:

describe('Tunnel Execution', () => {
  it('calls and returns from tunnel', () => {
    const player = createPlayer(\`
:: Start
Before.
-> Aside ->
After.

:: Aside
In aside.
->->
\`);

    const output = player.getFullOutput();
    expect(output).toEqual(['Before.', 'In aside.', 'After.']);
  });

  it('handles nested tunnels', () => {
    const player = createPlayer(\`
:: Start
-> A ->
Done.

:: A
In A.
-> B ->
Back in A.
->->

:: B
In B.
->->
\`);

    const output = player.getFullOutput();
    expect(output).toEqual(['In A.', 'In B.', 'Back in A.', 'Done.']);
  });

  it('errors on return without call', () => {
    const player = createPlayer(\`
:: Start
->->
\`);

    expect(() => player.run()).toThrow(/without tunnel call/);
  });

  it('handles tunnel with choices', () => {
    const player = createPlayer(\`
:: Start
-> Question ->
You answered.

:: Question
+ [Yes] ->->
+ [No] ->->
\`);

    expect(player.getChoices()).toHaveLength(2);
    player.choose(0);
    expect(player.getOutput()).toContain('You answered.');
  });

  it('prevents stack overflow', () => {
    const player = createPlayer(\`
:: Start
-> Start ->
\`);

    expect(() => player.run()).toThrow(/stack overflow/);
  });
});
```

## Expected Output
~80 lines runtime changes + ~100 lines tests.

## Verification
```bash
cd ~/code/github.com/writewhisker/whisker-editor-web

pnpm --filter @writewhisker/story-player test -- --run tunnel
```

## Next Stage
2.10-ts-runtime-once.md
