# Stage 2.14: Lua Tunnel Runtime

## Objective
Implement tunnel call stack and execution in Lua runtime.

## Dependencies
- Stage 2.13 (Lua gather runtime)

## Files to Modify
- `lib/whisker/runtime/player.lua`
- `lib/whisker/runtime/state.lua`

## Prompt

```
Implement tunnel execution in Lua runtime:

1. Add tunnel call stack to state:

-- In state.lua
local State = {}
State.__index = State

function State.new()
  return setmetatable({
    variables = {},
    visited_passages = {},
    history = {},
    tunnel_stack = {},  -- NEW: Tunnel call stack
  }, State)
end

function State:push_tunnel(return_passage_id, return_position, local_vars)
  table.insert(self.tunnel_stack, {
    return_passage_id = return_passage_id,
    return_position = return_position,
    local_variables = local_vars or {}
  })
end

function State:pop_tunnel()
  if #self.tunnel_stack == 0 then
    return nil
  end
  return table.remove(self.tunnel_stack)
end

function State:in_tunnel()
  return #self.tunnel_stack > 0
end

function State:tunnel_depth()
  return #self.tunnel_stack
end

2. Handle tunnel calls in player:

-- In player.lua
function Player:process_tunnel_call(tunnel_call)
  -- Save local/temp variables (those starting with _)
  local local_vars = {}
  for name, value in pairs(self.state.variables) do
    if name:sub(1, 1) == "_" then
      local_vars[name] = value
    end
  end

  -- Push return frame
  self.state:push_tunnel(
    self.current_passage_id,
    tunnel_call.position,
    local_vars
  )

  -- Navigate to tunnel target
  self:enter_passage(tunnel_call.target)
end

function Player:process_tunnel_return()
  local frame = self.state:pop_tunnel()
  if not frame then
    error("Tunnel return (<-) with empty stack")
  end

  -- Restore local variables
  for name, value in pairs(frame.local_variables) do
    self.state.variables[name] = value
  end

  -- Return to calling passage
  -- Note: Full implementation would resume at return_position
  self:enter_passage(frame.return_passage_id)
end

3. Detect tunnel calls and returns during content processing:
   - Check for tunnel_call nodes (-> Target ->)
   - Check for tunnel_return nodes (<-)
   - Call appropriate handler methods

4. Max depth check:
   if self.state:tunnel_depth() >= 100 then
     error("Maximum tunnel depth (100) exceeded")
   end
```

## Expected Output
~100 lines of Lua runtime code.

## Verification
```bash
cd whisker-core
busted spec/runtime/tunnel_spec.lua
```

## Success Criteria
- [ ] Tunnel calls navigate to target passage
- [ ] Tunnel returns pop stack and return
- [ ] Local variables (_prefixed) are preserved
- [ ] Nested tunnels work correctly
- [ ] Max depth error is raised appropriately

## Next Stage
2.15-corpus-flow-tests.md
