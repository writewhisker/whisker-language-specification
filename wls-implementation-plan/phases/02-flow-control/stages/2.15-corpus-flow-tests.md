# Stage 2.15: Corpus Gather/Tunnel Tests

## Objective
Add comprehensive test cases for gather points and tunnels to the test corpus.

## Dependencies
- Stage 2.14 (Lua tunnel runtime)
- Stage 2.10 (TS runtime complete)

## Files to Create
- `test-corpus/flow-control/gather-tests.yaml`
- `test-corpus/flow-control/tunnel-tests.yaml`

## Prompt

```
Create flow control test corpus:

1. Create test-corpus/flow-control/gather-tests.yaml:

tests:
  # Basic gather
  - name: gather-basic
    description: Simple gather after choices
    input: |
      :: Start
      Choose an option.
      + [Option A]
        You chose A.
      + [Option B]
        You chose B.
      - The story continues.
      + [End] -> END
    play:
      - select: 0
        output_contains: ["You chose A.", "The story continues."]
      - restart: true
      - select: 1
        output_contains: ["You chose B.", "The story continues."]

  # Multiple gathers
  - name: gather-multiple
    description: Multiple sequential gathers
    input: |
      :: Start
      First choice.
      + [A] Response A.
      + [B] Response B.
      - After first gather.
      + [C] Response C.
      + [D] Response D.
      - After second gather.
      -> END
    play:
      - select: 0
        output_contains: "After first gather"
      - select: 0
        output_contains: "After second gather"

  # Nested gathers
  - name: gather-nested
    description: Nested choice with nested gather
    input: |
      :: Start
      Main choice.
      + [Outer]
        Outer selected.
        + + [Inner A]
          Inner A selected.
        + + [Inner B]
          Inner B selected.
        - - After inner gather.
      + [Other]
        Other selected.
      - After outer gather.
      -> END
    play:
      - select: 0
        output_contains: "Outer selected"
      - select: 0
        output_contains: ["Inner A selected", "After inner gather", "After outer gather"]

  # Gather with conditional
  - name: gather-conditional
    description: Conditional after gather point
    input: |
      :: Start
      $score = 0
      + [Win] {do $score = 10}
      + [Lose] {do $score = 0}
      - {$score > 5}
        You won!
      {else}
        You lost.
      {/}
      -> END
    play:
      - select: 0
        output_contains: "You won!"
      - restart: true
      - select: 1
        output_contains: "You lost."

2. Create test-corpus/flow-control/tunnel-tests.yaml:

tests:
  # Basic tunnel
  - name: tunnel-basic
    description: Simple tunnel call and return
    input: |
      :: Start
      Before tunnel.
      -> Middle ->
      After tunnel.
      + [End] -> END

      :: Middle
      Inside tunnel.
      <-
    play:
      - output_sequence: ["Before tunnel.", "Inside tunnel.", "After tunnel."]

  # Chained tunnels
  - name: tunnel-chain
    description: Multiple sequential tunnel calls
    input: |
      :: Start
      Start.
      -> A ->
      -> B ->
      End.
      + [Done] -> END

      :: A
      In A.
      <-

      :: B
      In B.
      <-
    play:
      - output_sequence: ["Start.", "In A.", "In B.", "End."]

  # Nested tunnels
  - name: tunnel-nested
    description: Tunnel that calls another tunnel
    input: |
      :: Start
      Level 0.
      -> Level1 ->
      Back to 0.
      -> END

      :: Level1
      Level 1.
      -> Level2 ->
      Back to 1.
      <-

      :: Level2
      Level 2.
      <-
    play:
      - output_sequence: ["Level 0.", "Level 1.", "Level 2.", "Back to 1.", "Back to 0."]

  # Tunnel with choices
  - name: tunnel-choices
    description: Tunnel containing choices with gather
    input: |
      :: Start
      Before.
      -> Shop ->
      After shopping.
      + [Leave] -> END

      :: Shop
      What to buy?
      + [Sword] You bought a sword.
      + [Shield] You bought a shield.
      - Thanks for shopping!
      <-
    play:
      - output_contains: "Before"
      - select: 0
        output_contains: ["You bought a sword.", "Thanks for shopping!", "After shopping."]

  # Tunnel local variables
  - name: tunnel-local-vars
    description: Local variables preserved across tunnel
    input: |
      :: Start
      $_temp = "original"
      -> Modify ->
      After: $_temp
      -> END

      :: Modify
      $_temp = "modified"
      <-
    play:
      - output_contains: "After: original"
    note: Local variables (_prefixed) should be restored after tunnel return

  # Conditional tunnel return
  - name: tunnel-conditional-return
    description: Multiple return points in tunnel
    input: |
      :: Start
      $hasPass = true
      -> Guard ->
      Passed the guard.
      + [Continue] -> END

      :: Guard
      The guard checks you.
      {$hasPass}
        "You may pass."
        <-
      {/}
      "You cannot pass!"
      -> Prison
    play:
      - output_contains: ["You may pass.", "Passed the guard."]

3. Add validation error tests:

  - name: tunnel-orphan-return
    description: Tunnel return outside tunnel context
    input: |
      :: Start
      <-
    expected:
      errors:
        - code: WLS-FLW-011

  - name: tunnel-missing-return
    description: Tunnel passage without return
    input: |
      :: Start
      -> NoReturn ->
      After.

      :: NoReturn
      No return here.
      + [Continue] -> END
    expected:
      warnings:
        - code: WLS-FLW-010
```

## Expected Output
100+ test cases across both files.

## Verification
```bash
cd phase-4-validation
./tools/run-corpus.sh --category=flow-control --platform=typescript
./tools/run-corpus.sh --category=flow-control --platform=lua
./tools/compare-platforms.sh --category=flow-control
```

## Success Criteria
- [ ] All gather tests pass on TypeScript
- [ ] All gather tests pass on Lua
- [ ] All tunnel tests pass on TypeScript
- [ ] All tunnel tests pass on Lua
- [ ] Cross-platform parity verified

## Phase 2 Complete
Flow control implementation complete with gather points, tunnels, and corpus tests.
