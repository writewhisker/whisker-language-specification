# Stage 2.05: TypeScript - Parser Tunnels

## Objective
Add tunnel parsing to TypeScript parser.

## Files to Modify
- `packages/parser/src/whisker.pegjs`
- `packages/story-models/src/types.ts`

## Prompt

```
Update the TypeScript parser to support tunnels:

1. Update packages/story-models/src/types.ts:

export interface TunnelCallNode {
  type: 'tunnel_call';
  target: string;
  line: number;
}

export interface TunnelReturnNode {
  type: 'tunnel_return';
  line: number;
}

// Update PassageContent union
export type PassageContent =
  | TextNode
  | ChoiceNode
  | ConditionalNode
  | GatherNode
  | LinkNode
  | TunnelCallNode
  | TunnelReturnNode;

2. Update packages/parser/src/whisker.pegjs:

// Tunnel call: -> Target ->
TunnelCall
  = "->" _ target:PassageName _ "->" {
      return {
        type: 'tunnel_call',
        target: target,
        line: location().start.line
      };
    }

// Tunnel return: ->->
TunnelReturn
  = "->->" {
      return {
        type: 'tunnel_return',
        line: location().start.line
      };
    }

// Update Link rule to not match tunnels
Link
  = "->" _ !">" target:PassageName !("->" _) {
      return {
        type: 'link',
        target: target,
        line: location().start.line
      };
    }

// PassageContent priority (tunnel before link)
PassageContent
  = Choice
  / Gather
  / Conditional
  / TunnelReturn  // Must check before TunnelCall
  / TunnelCall    // Must check before Link
  / Link
  / Text

3. Create tests in packages/parser/src/tunnel.test.ts:

import { describe, it, expect } from 'vitest';
import { parse } from './index';

describe('Tunnels', () => {
  it('parses tunnel call', () => {
    const story = parse(\`
:: Start
Before
-> Aside ->
After
\`);
    const passage = story.passages[0];
    const tunnelCall = passage.content.find(n => n.type === 'tunnel_call');
    expect(tunnelCall).toBeDefined();
    expect(tunnelCall.target).toBe('Aside');
  });

  it('parses tunnel return', () => {
    const story = parse(\`
:: Aside
Content
->->
\`);
    const passage = story.passages[0];
    const tunnelReturn = passage.content.find(n => n.type === 'tunnel_return');
    expect(tunnelReturn).toBeDefined();
  });

  it('distinguishes tunnel from link', () => {
    const story = parse(\`
:: Start
-> Link
-> Tunnel ->
\`);
    // First is link, second is tunnel
  });

  it('tunnel return in choice', () => {
    const story = parse(\`
:: Question
+ [Yes] ->->
+ [No] ->->
\`);
    // Both choices should have tunnel returns
  });
});
```

## Expected Output
~40 lines types + ~40 lines grammar + ~60 lines tests.

## Verification
```bash
cd ~/code/github.com/writewhisker/whisker-editor-web

pnpm --filter @writewhisker/parser test -- --run tunnel
```

## Next Stage
2.06-ts-parser-inline-conditional.md
