# Stage 6.04: LIST State Machine Operators

## Objective
Extend LIST with state machine operators.

## Files to Modify
- `packages/scripting/src/list-operations.ts`
- `lib/whisker/runtime/list.lua`
- `spec/03-DATA-STRUCTURES.md`

## Prompt

```
Extend LIST with state machine operators:

1. Specification update (spec/03-DATA-STRUCTURES.md):

## LIST State Machines (WLS 2.0)

LISTs can function as state machines with transition operators.

### Operators

| Operator | Meaning | Example |
|----------|---------|---------|
| `+=` | Add state | `{do doorState += open}` |
| `-=` | Remove state | `{do doorState -= closed}` |
| `?` | Contains | `{doorState ? locked}` |
| `>=` | Includes (superset) | `{doorState >= unlocked}` |
| `<=` | Subset | `{doorState <= safe_states}` |

### Example

```whisker
LIST doorState = (closed), locked, unlocked, open

:: Door
{doorState ? closed}
The door is closed.
+ [Unlock] {do doorState -= closed, doorState += unlocked} -> Door
{/}
{doorState ? unlocked}
The door is unlocked.
+ [Open] {do doorState -= unlocked, doorState += open} -> Door
{/}
{doorState ? open}
The door stands open before you.
{/}
```

2. TypeScript implementation:

export class ListValue {
  private states: Set<string>;

  add(state: string): void {
    this.states.add(state);
  }

  remove(state: string): void {
    this.states.delete(state);
  }

  contains(state: string): boolean {
    return this.states.has(state);
  }

  includes(other: ListValue): boolean {
    for (const state of other.states) {
      if (!this.states.has(state)) return false;
    }
    return true;
  }

  isSubsetOf(other: ListValue): boolean {
    for (const state of this.states) {
      if (!other.states.has(state)) return false;
    }
    return true;
  }
}

3. Lua implementation with same interface.

4. Parser updates for operators.
```

## Expected Output
~150 lines TypeScript + ~100 lines Lua.

## Verification
```bash
pnpm --filter @writewhisker/scripting test -- --run list
```

## Next Stage
6.05-timed-content.md
