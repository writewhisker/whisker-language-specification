# Stage 6.02: Thread Scheduler Architecture

## Objective
Design and implement thread scheduler for parallel narrative.

## Files to Create
- `packages/story-player/src/ThreadScheduler.ts`
- `lib/whisker/runtime/thread_scheduler.lua`

## Prompt

```
Create thread scheduler:

1. packages/story-player/src/ThreadScheduler.ts:

export interface Thread {
  id: string;
  passage: string;
  contentIndex: number;
  localVariables: Map<string, unknown>;
  status: 'running' | 'waiting' | 'completed';
  priority: number;
}

export interface ThreadOutput {
  threadId: string;
  content: string[];
}

export class ThreadScheduler {
  private threads: Map<string, Thread> = new Map();
  private outputQueue: ThreadOutput[] = [];
  private mainThread: string = 'main';
  private nextThreadId = 1;

  createThread(passage: string, priority = 0): string {
    const id = \`thread_\${this.nextThreadId++}\`;
    this.threads.set(id, {
      id,
      passage,
      contentIndex: 0,
      localVariables: new Map(),
      status: 'running',
      priority
    });
    return id;
  }

  spawnThread(passage: string): string {
    // Syntax: -> ThreadPassage (spawn, don't wait)
    return this.createThread(passage);
  }

  awaitThread(threadId: string): void {
    // Block main thread until specified thread completes
    const thread = this.threads.get(threadId);
    if (thread) {
      thread.status = 'waiting';
    }
  }

  step(): ThreadOutput[] {
    const outputs: ThreadOutput[] = [];

    // Run each active thread for one step
    for (const thread of this.getActiveThreads()) {
      const output = this.stepThread(thread);
      if (output.length > 0) {
        outputs.push({ threadId: thread.id, content: output });
      }
    }

    return outputs;
  }

  private getActiveThreads(): Thread[] {
    return Array.from(this.threads.values())
      .filter(t => t.status === 'running')
      .sort((a, b) => b.priority - a.priority);
  }

  private stepThread(thread: Thread): string[] {
    // Execute one content node from thread's current position
    // Return any text output
    return [];
  }

  interleaveOutput(outputs: ThreadOutput[]): string[] {
    // Combine thread outputs in reading order
    // Priority threads first, then round-robin
    const result: string[] = [];
    for (const output of outputs) {
      result.push(...output.content);
    }
    return result;
  }

  terminateThread(threadId: string): void {
    this.threads.delete(threadId);
  }

  isComplete(): boolean {
    return Array.from(this.threads.values())
      .every(t => t.status === 'completed');
  }
}

2. Create Lua equivalent with same interface.

3. Add unit tests for scheduler behavior.
```

## Expected Output
~200 lines TypeScript + ~150 lines Lua.

## Verification
```bash
pnpm --filter @writewhisker/story-player test -- --run ThreadScheduler
```

## Next Stage
6.03-thread-syntax.md
