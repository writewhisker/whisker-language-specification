# Stage 3.05: Twine Importer Integration

## Objective
Combine archive parser and converters into complete Twine importer.

## Files to Create
- `packages/import/src/formats/TwineImporter.ts`
- `packages/import/src/formats/TwineImporter.test.ts`
- `packages/import/src/formats/index.ts`

## Prompt

```
Create complete Twine importer:

1. Create packages/import/src/formats/TwineImporter.ts:

import type { Importer, ImportResult, ImportOptions, ImportWarning } from '../types';
import type { Story, Passage } from '@writewhisker/story-models';
import { TwineArchiveParser } from './TwineArchiveParser';
import { HarloweConverter } from './HarloweConverter';
import { SugarCubeConverter } from './SugarCubeConverter';

export class TwineImporter implements Importer {
  name = 'twine';
  extensions = ['.html', '.tw'];
  mimeTypes = ['text/html'];

  private archiveParser = new TwineArchiveParser();
  private harloweConverter = new HarloweConverter();
  private sugarcubeConverter = new SugarCubeConverter();

  detect(content: string): boolean {
    return content.includes('<tw-storydata') ||
           content.includes('tw-passagedata');
  }

  async import(content: string, options?: ImportOptions): Promise<ImportResult> {
    const storyData = this.archiveParser.parse(content);
    const format = this.archiveParser.detectFormat(storyData);
    const warnings: ImportWarning[] = [];

    // Find start passage
    const startPassage = storyData.passages.find(
      p => p.pid === storyData.startNode
    );
    const startName = startPassage?.name || 'Start';

    // Convert each passage
    const passages: Passage[] = [];
    for (const twinePassage of storyData.passages) {
      // Convert content based on format
      let wlsContent: string;
      let conversionWarnings: ImportWarning[];

      if (format === 'harlowe') {
        const result = this.harloweConverter.convert(twinePassage.content);
        wlsContent = result.wls;
        conversionWarnings = result.warnings;
      } else if (format === 'sugarcube') {
        const result = this.sugarcubeConverter.convert(twinePassage.content);
        wlsContent = result.wls;
        conversionWarnings = result.warnings;
      } else {
        wlsContent = twinePassage.content;
        conversionWarnings = [{
          type: 'conversion_note',
          message: \`Unknown format: \${storyData.format}. Content imported as-is.\`
        }];
      }

      // Add passage-specific context to warnings
      for (const warning of conversionWarnings) {
        warning.location = { passage: twinePassage.name };
        warnings.push(warning);
      }

      // Rename start passage to "Start" if needed
      const passageName = twinePassage.name === startName && startName !== 'Start'
        ? 'Start'
        : twinePassage.name;

      passages.push({
        name: passageName,
        content: wlsContent,
        tags: twinePassage.tags,
        metadata: {
          position: twinePassage.position,
          originalName: twinePassage.name
        }
      });
    }

    // Build story
    const story: Story = {
      title: storyData.name,
      ifid: storyData.ifid,
      passages,
      metadata: {
        sourceFormat: 'twine',
        formatVersion: storyData.formatVersion
      }
    };

    return {
      story,
      warnings,
      metadata: {
        sourceFormat: \`twine/\${format}\`,
        sourceVersion: storyData.formatVersion,
        passageCount: passages.length,
        importedAt: new Date().toISOString()
      }
    };
  }
}

2. Create packages/import/src/formats/index.ts:

export { TwineImporter } from './TwineImporter';
export { TwineArchiveParser } from './TwineArchiveParser';
export { HarloweConverter } from './HarloweConverter';
export { SugarCubeConverter } from './SugarCubeConverter';

3. Create integration tests with sample Twine archives.
```

## Expected Output
~120 lines importer + ~100 lines tests.

## Verification
```bash
pnpm --filter @writewhisker/import test -- --run TwineImporter
```

## Next Stage
3.06-export-framework.md
