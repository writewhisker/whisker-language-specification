# Stage 3.03: Harlowe Syntax Converter

## Objective
Convert Harlowe 3.x syntax to WLS.

## Files to Create
- `packages/import/src/formats/HarloweConverter.ts`
- `packages/import/src/formats/HarloweConverter.test.ts`

## Prompt

```
Create Harlowe to WLS converter:

1. Create packages/import/src/formats/HarloweConverter.ts:

import type { ImportWarning } from '../types';

export class HarloweConverter {
  private warnings: ImportWarning[] = [];

  convert(harloweContent: string): { wls: string; warnings: ImportWarning[] } {
    this.warnings = [];
    let wls = harloweContent;

    // Variable assignment: (set: $var to value) -> {do $var = value}
    wls = this.convertSet(wls);

    // Conditionals: (if: condition)[content] -> {condition}\ncontent\n{/}
    wls = this.convertIf(wls);

    // Links: [[text|target]] or [[target]] -> + [text] -> target
    wls = this.convertLinks(wls);

    // Print: (print: $var) -> $var
    wls = this.convertPrint(wls);

    // Goto: (goto: "passage") -> -> passage
    wls = this.convertGoto(wls);

    // Unsupported macros
    wls = this.flagUnsupported(wls);

    return { wls, warnings: this.warnings };
  }

  private convertSet(content: string): string {
    // (set: $var to value) -> {do $var = value}
    return content.replace(
      /\(set:\s*\$(\w+)\s+to\s+(.+?)\)/gi,
      '{do $$1 = $2}'
    );
  }

  private convertIf(content: string): string {
    // (if: condition)[content] -> {condition}\ncontent\n{/}
    // This is simplified - real implementation needs bracket matching
    return content.replace(
      /\(if:\s*(.+?)\)\[([^\]]*)\]/gi,
      '{$1}\n$2\n{/}'
    );
  }

  private convertLinks(content: string): string {
    // [[text|target]] -> + [text] -> target
    let result = content.replace(
      /\[\[([^\]|]+)\|([^\]]+)\]\]/g,
      '+ [$1] -> $2'
    );

    // [[target]] -> + [target] -> target
    result = result.replace(
      /\[\[([^\]|]+)\]\]/g,
      '+ [$1] -> $1'
    );

    return result;
  }

  private convertPrint(content: string): string {
    // (print: $var) -> $var
    return content.replace(
      /\(print:\s*\$(\w+)\)/gi,
      '$$1'
    );
  }

  private convertGoto(content: string): string {
    // (goto: "passage") -> -> passage
    return content.replace(
      /\(goto:\s*"([^"]+)"\)/gi,
      '-> $1'
    );
  }

  private flagUnsupported(content: string): string {
    // Find unsupported macros and add warnings
    const unsupported = [
      'live', 'stop', 'display', 'enchant', 'click',
      'mouseover', 'replace', 'append', 'prepend'
    ];

    for (const macro of unsupported) {
      const regex = new RegExp(\`\\(\${macro}:[^)]*\\)\`, 'gi');
      const matches = content.match(regex);
      if (matches) {
        for (const match of matches) {
          this.warnings.push({
            type: 'unsupported_feature',
            message: \`Unsupported Harlowe macro: \${macro}\`,
            original: match
          });
        }
      }
    }

    return content;
  }
}

2. Create comprehensive tests covering:
   - Variable conversions
   - Conditional blocks
   - Link formats
   - Unsupported macro warnings
```

## Expected Output
~120 lines converter + ~100 lines tests.

## Verification
```bash
pnpm --filter @writewhisker/import test -- --run HarloweConverter
```

## Next Stage
3.04-sugarcube-converter.md
