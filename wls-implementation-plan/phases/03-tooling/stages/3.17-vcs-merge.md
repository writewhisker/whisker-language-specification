# Stage 3.17: VCS Merge Tool

## Objective
Create story-aware merge tool for WLS conflict resolution.

## Dependencies
- Stage 3.16 (VCS diff)

## Files to Create
- `packages/cli/src/commands/merge.ts`
- `packages/vcs/src/merge.ts`
- `packages/vcs/src/merge.test.ts`

## Prompt

```
Create semantic merge for WLS files:

1. Problem: Text-based merge creates invalid stories
   - Passage conflicts hard to resolve
   - Structural conflicts (choice nesting) break syntax
   - Variable conflicts can cause runtime errors

2. Create packages/vcs/src/merge.ts:

import { parse, serialize } from '@writewhisker/parser';
import type { Story, Passage } from '@writewhisker/story-models';

interface MergeResult {
  success: boolean;
  merged?: Story;
  conflicts: MergeConflict[];
  autoResolved: AutoResolution[];
}

interface MergeConflict {
  type: 'passage' | 'variable' | 'metadata' | 'structure';
  location: string;
  base: string;
  ours: string;
  theirs: string;
  suggestions?: string[];
}

interface AutoResolution {
  type: string;
  location: string;
  resolution: string;
  reason: string;
}

export function merge(
  base: string,
  ours: string,
  theirs: string
): MergeResult {
  const baseStory = parse(base);
  const ourStory = parse(ours);
  const theirStory = parse(theirs);

  const conflicts: MergeConflict[] = [];
  const autoResolved: AutoResolution[] = [];
  const mergedStory = baseStory.clone();

  // Merge metadata
  mergeMetadata(baseStory, ourStory, theirStory, mergedStory, conflicts, autoResolved);

  // Merge variables
  mergeVariables(baseStory, ourStory, theirStory, mergedStory, conflicts, autoResolved);

  // Merge passages
  mergePassages(baseStory, ourStory, theirStory, mergedStory, conflicts, autoResolved);

  return {
    success: conflicts.length === 0,
    merged: conflicts.length === 0 ? mergedStory : undefined,
    conflicts,
    autoResolved,
  };
}

function mergePassages(
  base: Story,
  ours: Story,
  theirs: Story,
  merged: Story,
  conflicts: MergeConflict[],
  autoResolved: AutoResolution[]
): void {
  const basePassages = new Map(
    Array.from(base.passages.values()).map(p => [p.title, p])
  );
  const ourPassages = new Map(
    Array.from(ours.passages.values()).map(p => [p.title, p])
  );
  const theirPassages = new Map(
    Array.from(theirs.passages.values()).map(p => [p.title, p])
  );

  // All unique passage titles
  const allTitles = new Set([
    ...basePassages.keys(),
    ...ourPassages.keys(),
    ...theirPassages.keys(),
  ]);

  for (const title of allTitles) {
    const baseP = basePassages.get(title);
    const ourP = ourPassages.get(title);
    const theirP = theirPassages.get(title);

    // Both added same new passage
    if (!baseP && ourP && theirP) {
      if (passageEquals(ourP, theirP)) {
        merged.passages.set(ourP.id, ourP);
        autoResolved.push({
          type: 'passage',
          location: title,
          resolution: 'kept',
          reason: 'Both branches added identical passage',
        });
      } else {
        conflicts.push({
          type: 'passage',
          location: title,
          base: '',
          ours: serialize(ourP),
          theirs: serialize(theirP),
        });
      }
      continue;
    }

    // One side added
    if (!baseP && ourP && !theirP) {
      merged.passages.set(ourP.id, ourP);
      autoResolved.push({
        type: 'passage',
        location: title,
        resolution: 'added from ours',
        reason: 'New passage in our branch',
      });
      continue;
    }
    if (!baseP && !ourP && theirP) {
      merged.passages.set(theirP.id, theirP);
      autoResolved.push({
        type: 'passage',
        location: title,
        resolution: 'added from theirs',
        reason: 'New passage in their branch',
      });
      continue;
    }

    // Both deleted
    if (baseP && !ourP && !theirP) {
      // Don't add to merged
      autoResolved.push({
        type: 'passage',
        location: title,
        resolution: 'deleted',
        reason: 'Both branches deleted passage',
      });
      continue;
    }

    // One side deleted, other modified
    if (baseP && !ourP && theirP && !passageEquals(baseP, theirP)) {
      conflicts.push({
        type: 'passage',
        location: title,
        base: serialize(baseP),
        ours: '(deleted)',
        theirs: serialize(theirP),
      });
      continue;
    }

    // Both modified
    if (baseP && ourP && theirP) {
      const ourChanged = !passageEquals(baseP, ourP);
      const theirChanged = !passageEquals(baseP, theirP);

      if (ourChanged && theirChanged) {
        if (passageEquals(ourP, theirP)) {
          // Same changes
          merged.passages.set(ourP.id, ourP);
          autoResolved.push({
            type: 'passage',
            location: title,
            resolution: 'both same',
            reason: 'Both branches made identical changes',
          });
        } else {
          // Different changes - conflict
          conflicts.push({
            type: 'passage',
            location: title,
            base: serialize(baseP),
            ours: serialize(ourP),
            theirs: serialize(theirP),
          });
        }
      } else if (ourChanged) {
        merged.passages.set(ourP.id, ourP);
      } else if (theirChanged) {
        merged.passages.set(theirP.id, theirP);
      } else {
        // No changes
        merged.passages.set(baseP.id, baseP);
      }
    }
  }
}

3. Conflict markers for manual resolution:

   :: ConflictedPassage
   <<<<<<< OURS
   Our version of the content.
   =======
   Their version of the content.
   >>>>>>> THEIRS

4. Git integration:

   # .gitattributes
   *.ws merge=whisker

   # .gitconfig
   [merge "whisker"]
     name = Whisker story merge
     driver = whisker merge %O %A %B -o %A

5. Interactive conflict resolution (optional):

   whisker merge base.ws ours.ws theirs.ws --interactive

   Conflict in passage "Start":
   [1] Keep ours
   [2] Keep theirs
   [3] Edit manually
   [4] Show diff
   >
```

## Expected Output
~300 lines merge implementation + ~150 lines tests.

## Verification
```bash
# Create conflict scenario
echo ':: Start\nOriginal' > base.ws
echo ':: Start\nOur change' > ours.ws
echo ':: Start\nTheir change' > theirs.ws

# Run merge
whisker merge base.ws ours.ws theirs.ws -o merged.ws
```

## Success Criteria
- [ ] Clean merges produce valid stories
- [ ] Conflicts are clearly identified
- [ ] Auto-resolutions are correct
- [ ] Conflict markers are valid WLS syntax
- [ ] Git merge driver works
- [ ] Interactive mode functional

## Phase 3 Complete
Tooling phase complete with import, export, publishing, and VCS tools.
