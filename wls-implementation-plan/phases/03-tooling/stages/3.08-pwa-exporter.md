# Stage 3.08: PWA Exporter

## Objective
Export stories as installable Progressive Web Apps.

## Files to Create
- `packages/export/src/formats/PWAExporter.ts`
- `packages/export/src/formats/PWAExporter.test.ts`

## Prompt

```
Create PWA exporter:

1. Create packages/export/src/formats/PWAExporter.ts:

import type { Exporter, ExportResult, ExportOptions, ExportFile } from '../types';
import type { Story } from '@writewhisker/story-models';
import { HTMLExporter } from './HTMLExporter';

const MANIFEST_TEMPLATE = {
  name: '',
  short_name: '',
  start_url: './index.html',
  display: 'standalone',
  background_color: '#ffffff',
  theme_color: '#4a90d9',
  icons: []
};

const SERVICE_WORKER = \`
const CACHE_NAME = 'story-cache-v1';
const urlsToCache = [
  './',
  './index.html',
  './manifest.json'
];

self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => response || fetch(event.request))
  );
});
\`;

export class PWAExporter implements Exporter {
  name = 'pwa';
  extension = '.zip';
  mimeType = 'application/zip';

  private htmlExporter = new HTMLExporter();

  async export(story: Story, options?: ExportOptions): Promise<ExportResult> {
    const title = options?.title || story.title || 'Untitled Story';
    const shortName = title.substring(0, 12);

    // Generate HTML with service worker registration
    const htmlResult = await this.htmlExporter.export(story, {
      ...options,
      customJs: \`
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('./sw.js');
        }
      \`
    });

    // Add link to manifest in HTML
    let html = htmlResult.content as string;
    html = html.replace(
      '</head>',
      '<link rel="manifest" href="./manifest.json">\\n</head>'
    );

    // Create manifest
    const manifest = {
      ...MANIFEST_TEMPLATE,
      name: title,
      short_name: shortName,
      icons: [
        { src: './icon-192.png', sizes: '192x192', type: 'image/png' },
        { src: './icon-512.png', sizes: '512x512', type: 'image/png' }
      ]
    };

    // Generate placeholder icons (base64 SVG)
    const icon192 = this.generateIcon(192, title.charAt(0));
    const icon512 = this.generateIcon(512, title.charAt(0));

    const additionalFiles: ExportFile[] = [
      {
        path: 'manifest.json',
        content: JSON.stringify(manifest, null, 2),
        mimeType: 'application/json'
      },
      {
        path: 'sw.js',
        content: SERVICE_WORKER,
        mimeType: 'application/javascript'
      },
      {
        path: 'icon-192.png',
        content: icon192,
        mimeType: 'image/png'
      },
      {
        path: 'icon-512.png',
        content: icon512,
        mimeType: 'image/png'
      }
    ];

    return {
      content: html,
      filename: 'index.html',
      mimeType: 'text/html',
      additionalFiles
    };
  }

  private generateIcon(size: number, letter: string): Buffer {
    // Generate simple SVG icon and convert to PNG
    // In real implementation, use canvas or sharp
    const svg = \`
      <svg width="\${size}" height="\${size}" xmlns="http://www.w3.org/2000/svg">
        <rect width="100%" height="100%" fill="#4a90d9"/>
        <text x="50%" y="55%" font-size="\${size * 0.6}"
          text-anchor="middle" fill="white" font-family="sans-serif">
          \${letter.toUpperCase()}
        </text>
      </svg>
    \`;
    // For now, return SVG as buffer (real impl would convert to PNG)
    return Buffer.from(svg);
  }
}

2. Create tests verifying:
   - manifest.json is valid
   - Service worker is included
   - HTML includes manifest link
   - Icons are generated
```

## Expected Output
~120 lines exporter + ~60 lines tests.

## Verification
```bash
pnpm --filter @writewhisker/export test -- --run PWAExporter
```

## Next Stage
3.09-cli-commands.md
