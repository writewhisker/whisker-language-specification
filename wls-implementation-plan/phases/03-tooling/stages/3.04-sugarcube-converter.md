# Stage 3.04: SugarCube Syntax Converter

## Objective
Convert SugarCube 2.x syntax to WLS.

## Files to Create
- `packages/import/src/formats/SugarCubeConverter.ts`
- `packages/import/src/formats/SugarCubeConverter.test.ts`

## Prompt

```
Create SugarCube to WLS converter:

1. Create packages/import/src/formats/SugarCubeConverter.ts:

import type { ImportWarning } from '../types';

export class SugarCubeConverter {
  private warnings: ImportWarning[] = [];

  convert(scContent: string): { wls: string; warnings: ImportWarning[] } {
    this.warnings = [];
    let wls = scContent;

    // Variable assignment: <<set $var to value>> -> {do $var = value}
    wls = this.convertSet(wls);

    // Conditionals: <<if cond>>content<<endif>> -> {cond}\ncontent\n{/}
    wls = this.convertIf(wls);

    // Links: [[text|target]] -> + [text] -> target
    wls = this.convertLinks(wls);

    // Print: <<print $var>> or <<= $var>> -> $var
    wls = this.convertPrint(wls);

    // Goto: <<goto "passage">> -> -> passage
    wls = this.convertGoto(wls);

    // Unsupported macros
    wls = this.flagUnsupported(wls);

    return { wls, warnings: this.warnings };
  }

  private convertSet(content: string): string {
    // <<set $var to value>> -> {do $var = value}
    return content.replace(
      /<<set\s+\$(\w+)\s+to\s+(.+?)>>/gi,
      '{do $$1 = $2}'
    );
  }

  private convertIf(content: string): string {
    let result = content;

    // <<if cond>> -> {cond}
    result = result.replace(
      /<<if\s+(.+?)>>/gi,
      '{$1}'
    );

    // <<elseif cond>> -> {elif cond}
    result = result.replace(
      /<<elseif\s+(.+?)>>/gi,
      '{elif $1}'
    );

    // <<else>> -> {else}
    result = result.replace(/<<else>>/gi, '{else}');

    // <<endif>> or <</if>> -> {/}
    result = result.replace(/<<\/?endif>>/gi, '{/}');
    result = result.replace(/<<\/if>>/gi, '{/}');

    return result;
  }

  private convertLinks(content: string): string {
    // [[text|target]] -> + [text] -> target
    let result = content.replace(
      /\[\[([^\]|]+)\|([^\]]+)\]\]/g,
      '+ [$1] -> $2'
    );

    // [[text->target]] (SugarCube arrow syntax)
    result = result.replace(
      /\[\[([^\]]+)->([^\]]+)\]\]/g,
      '+ [$1] -> $2'
    );

    // [[target]] -> + [target] -> target
    result = result.replace(
      /\[\[([^\]|]+)\]\]/g,
      '+ [$1] -> $1'
    );

    return result;
  }

  private convertPrint(content: string): string {
    // <<print $var>> -> $var
    let result = content.replace(
      /<<print\s+\$(\w+)>>/gi,
      '$$1'
    );

    // <<= $var>> -> $var
    result = result.replace(
      /<<-?\s*\$(\w+)>>/gi,
      '$$1'
    );

    return result;
  }

  private convertGoto(content: string): string {
    // <<goto "passage">> -> -> passage
    return content.replace(
      /<<goto\s+"([^"]+)">>/gi,
      '-> $1'
    );
  }

  private flagUnsupported(content: string): string {
    const unsupported = [
      'timed', 'repeat', 'widget', 'button', 'checkbox',
      'cycle', 'listbox', 'radiobutton', 'textarea',
      'audio', 'cacheaudio', 'playlist'
    ];

    for (const macro of unsupported) {
      const regex = new RegExp(\`<<\${macro}[^>]*>>\`, 'gi');
      const matches = content.match(regex);
      if (matches) {
        for (const match of matches) {
          this.warnings.push({
            type: 'unsupported_feature',
            message: \`Unsupported SugarCube macro: \${macro}\`,
            original: match
          });
        }
      }
    }

    return content;
  }
}

2. Create tests for all conversions.
```

## Expected Output
~130 lines converter + ~100 lines tests.

## Verification
```bash
pnpm --filter @writewhisker/import test -- --run SugarCubeConverter
```

## Next Stage
3.05-twine-importer.md
