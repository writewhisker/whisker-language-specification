# Stage 3.02: Twine Archive Parser

## Objective
Parse Twine 2 archive format (HTML with tw-storydata).

## Files to Create
- `packages/import/src/formats/TwineArchiveParser.ts`
- `packages/import/src/formats/TwineArchiveParser.test.ts`

## Prompt

```
Create Twine archive parser:

1. Create packages/import/src/formats/TwineArchiveParser.ts:

export interface TwineStoryData {
  name: string;
  ifid: string;
  format: string;
  formatVersion: string;
  startNode: string;
  passages: TwinePassage[];
  styles?: string;
  scripts?: string;
}

export interface TwinePassage {
  pid: string;
  name: string;
  tags: string[];
  position: { x: number; y: number };
  size?: { width: number; height: number };
  content: string;
}

export class TwineArchiveParser {
  parse(html: string): TwineStoryData {
    // Parse HTML to extract tw-storydata element
    const storyDataMatch = html.match(/<tw-storydata([^>]*)>([\s\S]*?)<\/tw-storydata>/);
    if (!storyDataMatch) {
      throw new Error('Not a valid Twine archive: missing tw-storydata');
    }

    const attributes = this.parseAttributes(storyDataMatch[1]);
    const content = storyDataMatch[2];

    // Parse passages
    const passages = this.parsePassages(content);

    // Parse styles and scripts
    const styles = this.extractElement(content, 'style');
    const scripts = this.extractElement(content, 'script');

    return {
      name: attributes.name || 'Untitled',
      ifid: attributes.ifid || '',
      format: attributes.format || 'Unknown',
      formatVersion: attributes['format-version'] || '',
      startNode: attributes.startnode || '1',
      passages,
      styles,
      scripts
    };
  }

  private parseAttributes(attrString: string): Record<string, string> {
    const attrs: Record<string, string> = {};
    const regex = /(\w[\w-]*)="([^"]*)"/g;
    let match;
    while ((match = regex.exec(attrString)) !== null) {
      attrs[match[1].toLowerCase()] = this.decodeHtml(match[2]);
    }
    return attrs;
  }

  private parsePassages(content: string): TwinePassage[] {
    const passages: TwinePassage[] = [];
    const passageRegex = /<tw-passagedata([^>]*)>([\s\S]*?)<\/tw-passagedata>/g;
    let match;

    while ((match = passageRegex.exec(content)) !== null) {
      const attrs = this.parseAttributes(match[1]);
      const passageContent = this.decodeHtml(match[2]);

      passages.push({
        pid: attrs.pid || '',
        name: attrs.name || '',
        tags: (attrs.tags || '').split(' ').filter(t => t),
        position: {
          x: parseFloat(attrs.position?.split(',')[0] || '0'),
          y: parseFloat(attrs.position?.split(',')[1] || '0')
        },
        content: passageContent
      });
    }

    return passages;
  }

  private decodeHtml(text: string): string {
    return text
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&amp;/g, '&')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'");
  }

  private extractElement(content: string, tag: string): string | undefined {
    const match = content.match(new RegExp(\`<\${tag}[^>]*>([\\s\\S]*?)</\${tag}>\`));
    return match ? match[1] : undefined;
  }

  detectFormat(storyData: TwineStoryData): 'harlowe' | 'sugarcube' | 'unknown' {
    const format = storyData.format.toLowerCase();
    if (format.includes('harlowe')) return 'harlowe';
    if (format.includes('sugarcube')) return 'sugarcube';
    return 'unknown';
  }
}

2. Create tests verifying:
   - Parsing valid Twine 2 archive
   - Extracting all passages
   - Handling HTML entities
   - Detecting Harlowe vs SugarCube
```

## Expected Output
~150 lines parser + ~80 lines tests.

## Verification
```bash
pnpm --filter @writewhisker/import test -- --run TwineArchiveParser
```

## Next Stage
3.03-harlowe-converter.md
