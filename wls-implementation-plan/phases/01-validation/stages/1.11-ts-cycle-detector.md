# Stage 1.11: TypeScript - Cycle Detector Validator

## Objective
Implement the CycleDetectorValidator for TypeScript.

## Files to Create
- `packages/story-validation/src/validators/CycleDetectorValidator.ts`
- `packages/story-validation/src/validators/CycleDetectorValidator.test.ts`

## Prompt

```
Create the CycleDetectorValidator in whisker-editor-web:

1. Create validator at:
/Users/jims/code/github.com/writewhisker/whisker-editor-web/packages/story-validation/src/validators/CycleDetectorValidator.ts

import type { Story } from '@writewhisker/story-models';
import type { StoryValidator, WLSValidationError } from '../types';
import { createValidationError } from '../types';

export class CycleDetectorValidator implements StoryValidator {
  name = 'CycleDetectorValidator';
  errorCodes = ['WLS-FLW-003', 'WLS-FLW-004'];

  validate(story: Story): WLSValidationError[] {
    const errors: WLSValidationError[] = [];
    const graph = this.buildGraph(story);

    // Find cycles using DFS
    const visited = new Set<string>();
    const recursionStack = new Set<string>();
    const cycles: string[][] = [];

    const dfs = (node: string, path: string[]): void => {
      visited.add(node);
      recursionStack.add(node);
      path.push(node);

      for (const neighbor of graph.get(node) ?? []) {
        if (!visited.has(neighbor)) {
          dfs(neighbor, [...path]);
        } else if (recursionStack.has(neighbor)) {
          // Found cycle
          const cycleStart = path.indexOf(neighbor);
          cycles.push(path.slice(cycleStart));
        }
      }

      recursionStack.delete(node);
    };

    // Start from all nodes to find all cycles
    for (const node of graph.keys()) {
      if (!visited.has(node)) {
        dfs(node, []);
      }
    }

    // Report cycles
    for (const cycle of cycles) {
      const isInfiniteLoop = this.isInfiniteLoop(story, cycle);
      const code = isInfiniteLoop ? 'WLS-FLW-004' : 'WLS-FLW-003';
      const cyclePath = cycle.join(' -> ');

      errors.push(createValidationError(
        code,
        [cyclePath],
        { passage: cycle[0] },
        { cycle }
      ));
    }

    return errors;
  }

  private buildGraph(story: Story): Map<string, string[]> {
    const graph = new Map<string, string[]>();

    for (const passage of story.passages) {
      const targets: string[] = [];

      // Add choice targets
      for (const choice of passage.choices ?? []) {
        if (choice.target) targets.push(choice.target);
      }

      // Add link targets
      for (const link of passage.links ?? []) {
        if (link.target) targets.push(link.target);
      }

      graph.set(passage.name, targets);
    }

    return graph;
  }

  private isInfiniteLoop(story: Story, cycle: string[]): boolean {
    // A cycle is an infinite loop if it has no choices (unconditional)
    for (const passageName of cycle) {
      const passage = story.passages.find(p => p.name === passageName);
      if (passage?.choices && passage.choices.length > 0) {
        return false; // Has choices, player can break out
      }
    }
    return true;
  }
}

2. Create test file at:
/Users/jims/code/github.com/writewhisker/whisker-editor-web/packages/story-validation/src/validators/CycleDetectorValidator.test.ts

import { describe, it, expect } from 'vitest';
import { CycleDetectorValidator } from './CycleDetectorValidator';
import { parse } from '@writewhisker/parser';

describe('CycleDetectorValidator', () => {
  const validator = new CycleDetectorValidator();

  it('passes when no cycles', () => {
    const story = parse(`
:: Start
+ [Go] -> Middle

:: Middle
+ [End] -> END
`);
    const errors = validator.validate(story);
    expect(errors).toHaveLength(0);
  });

  it('detects simple cycle', () => {
    const story = parse(`
:: Start
+ [A] -> A

:: A
+ [B] -> B

:: B
+ [Back] -> A
`);
    const errors = validator.validate(story);
    expect(errors.length).toBeGreaterThan(0);
    expect(errors[0].code).toBe('WLS-FLW-003');
  });

  it('detects infinite loop (no choices)', () => {
    const story = parse(`
:: Start
-> A

:: A
-> B

:: B
-> A
`);
    const errors = validator.validate(story);
    expect(errors.some(e => e.code === 'WLS-FLW-004')).toBe(true);
  });

  it('self-loop without choices is infinite', () => {
    const story = parse(`
:: Start
-> Loop

:: Loop
-> Loop
`);
    const errors = validator.validate(story);
    expect(errors.some(e => e.code === 'WLS-FLW-004')).toBe(true);
  });
});

3. Register in validators/index.ts.
```

## Expected Output
~100 lines validator + ~70 lines tests.

## Verification
```bash
cd ~/code/github.com/writewhisker/whisker-editor-web

pnpm --filter @writewhisker/story-validation test -- --run CycleDetectorValidator
```

## Next Stage
1.12-ts-update-existing-validators.md
