# WLS 2.0 Implementation Plan Overview

## Executive Summary

WLS 2.0 is a major version release that introduces advanced narrative features, enhanced runtime capabilities, and expanded media support. This release may include breaking changes where necessary to enable powerful new features.

## Vision

WLS 2.0 aims to match or exceed the capabilities of Ink, Harlowe, and SugarCube while maintaining the clean, learnable syntax that defines WLS. The focus is on:

1. **Parallel Narrative** - Threads for simultaneous storylines
2. **State Machines** - Lists as first-class narrative state
3. **Rich Media** - Full audio/video API with timing controls
4. **Extensibility** - External function binding and plugins

## WLS 2.0 Feature Set

### 1. Threads (Parallel Content)

**Source:** Ink threads
**Priority:** P1
**Complexity:** Very High

Threads allow multiple narrative streams to execute simultaneously, interweaving content.

```whisker
:: Dinner
-> AmbientDining
The waiter approaches your table.
+ [Order wine] -> OrderWine
+ [Order water] -> OrderWater

== AmbientDining
{~|A couple argues at the next table.|Music plays softly.|Glasses clink.}
-> AmbientDining  // Continues in background
```

**Implementation:**
- Thread scheduler in runtime
- Content interleaving
- Thread-local variables
- Thread synchronization primitives

---

### 2. Lists as State Machines

**Source:** Ink LIST system
**Priority:** P1
**Complexity:** High

Extend LIST to function as state machines with transitions.

```whisker
LIST doorState = (closed), locked, unlocked, open

:: Door
{doorState ? closed}
The door is closed.
+ [Try to open] {do doorState += unlocked, doorState -= closed} -> Door
{/}
{doorState ? open}
The door stands open.
{/}

// State queries
{doorState >= unlocked}
You can pass through.
{/}
```

**Features:**
- State transitions with `+=` / `-=`
- State queries with `?` (contains) and `>=` (includes)
- Multi-value states
- State ranges and comparisons

---

### 3. Timed Content

**Source:** SugarCube `<<timed>>`
**Priority:** P2
**Complexity:** Medium

Content that reveals or changes over time.

```whisker
:: Suspense
You wait in the darkness.

@delay 2s {
Suddenly, you hear footsteps.
}

@delay 4s {
The door creaks open...
}

@delay 6s {
+ [Hide!] -> Hide
+ [Confront them] -> Confront
}
```

**Features:**
- Delayed content reveal
- Timed choice availability
- Animation integration
- Pause/resume support

---

### 4. External Function Binding

**Source:** Ink external functions
**Priority:** P2
**Complexity:** High

Allow stories to call external (host application) functions.

```whisker
EXTERNAL playSound(soundId)
EXTERNAL getUserName()
EXTERNAL saveAchievement(achievementId)

:: Victory
{do playSound("fanfare")}
Congratulations, ${getUserName()}!
{do saveAchievement("game_complete")}
```

**Implementation:**
- Function registration API
- Type checking for parameters
- Return value handling
- Sandboxing for web context

---

### 5. Audio/Media API

**Source:** SugarCube, Chapbook
**Priority:** P2
**Complexity:** Medium

First-class audio and media controls.

```whisker
@audio: bgm = "music/theme.mp3" loop volume:0.7
@audio: sfx = "sounds/door.wav"

:: Start
{do whisker.audio.play("bgm")}
You enter the castle.

+ [Open the door] {do whisker.audio.play("sfx")} -> Hall

:: Hall
{do whisker.audio.fadeOut("bgm", 2000)}
{do whisker.audio.play("battle_theme")}
```

**Features:**
- Audio channels (bgm, sfx, voice)
- Crossfade and volume control
- Preloading
- Spatial audio (optional)

---

### 6. Text Effects and Transitions

**Source:** Harlowe, SugarCube
**Priority:** P3
**Complexity:** Medium

Dynamic text presentation effects.

```whisker
:: Dramatic
@transition: fade-in 1s
The truth is revealed...

@effect: typewriter 50ms {
"I am your father."
}

@effect: shake {
BOOM!
}
```

**Features:**
- Transition effects (fade, slide, etc.)
- Text animations (typewriter, shake, pulse)
- Custom CSS animations
- Platform-specific fallbacks

---

### 7. Hooks System

**Source:** Harlowe
**Priority:** P3
**Complexity:** Medium

Named text regions for dynamic modification.

```whisker
:: Garden
You see |flowers>[beautiful flowers] in the garden.

+ [Examine flowers] {
  @replace: flowers {
    wilted roses, their petals scattered on the ground
  }
}
```

**Features:**
- Named hooks with `|name>[content]`
- Replace, append, prepend operations
- Show/hide hooks
- Hook transitions

---

### 8. Parameterized Passages

**Source:** Ink, programming languages
**Priority:** P2
**Complexity:** Medium

Passages that accept parameters.

```whisker
:: Describe(item, quality)
You examine the $item carefully.
{quality == "good"}
It's in excellent condition.
{else}
It's seen better days.
{/}

:: Inventory
-> Describe("sword", "good") ->
-> Describe("shield", "worn") ->
```

**Features:**
- Passage parameters
- Default values
- Type hints (optional)
- Works with tunnels

---

## Implementation Phases

### Phase 2.0.1: Foundation
1. Runtime architecture for threads
2. Enhanced LIST implementation
3. State machine semantics
4. Updated parser for new syntax

### Phase 2.0.2: Parallel Narrative
1. Thread scheduler
2. Content interleaving
3. Thread variables
4. Thread synchronization

### Phase 2.0.3: State Machines
1. LIST transitions
2. State queries
3. Multi-value states
4. State-based conditions

### Phase 2.0.4: Timing and Media
1. Timed content system
2. Audio API
3. Video integration
4. Animation support

### Phase 2.0.5: Extensibility
1. External function binding
2. Plugin architecture
3. Security sandboxing
4. Type system for externals

### Phase 2.0.6: Presentation
1. Text effects
2. Transitions
3. Hooks system
4. Theme API enhancements

### Phase 2.0.7: Advanced Features
1. Parameterized passages
2. Advanced pattern matching
3. Story includes with parameters
4. Macro system

## Breaking Changes

WLS 2.0 may include these breaking changes:

| Change | Reason | Migration |
|--------|--------|-----------|
| LIST syntax | State machine support | Auto-migration tool |
| Thread keywords | New reserved words | Rename conflicts |
| Timing attributes | New `@delay` syntax | None (additive) |

## Success Metrics

| Metric | WLS 1.1 | WLS 2.0 Target |
|--------|---------|----------------|
| Ink feature parity | 70% | 95% |
| Harlowe feature parity | 80% | 90% |
| SugarCube feature parity | 75% | 85% |
| Thread support | None | Full |
| List states | Basic | Full |
| Media API | Basic | Complete |
| External functions | None | Full |

## Dependencies

```
Threads
├── Requires: Runtime scheduler
├── Requires: Thread-safe state
└── Enables: Complex narratives

LIST State Machines
├── Requires: Enhanced LIST parser
├── Requires: State transition runtime
└── Enables: Game mechanics

Timed Content
├── Requires: Timer system
├── Requires: Presentation layer
└── Enables: Cinematic effects

External Functions
├── Requires: Type system
├── Requires: Sandbox
└── Enables: Game integration
```

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| Thread complexity | Very High | Incremental delivery |
| Breaking changes | High | Migration tools |
| Performance | High | Benchmarking |
| Cross-platform parity | High | Shared test corpus |
| Feature creep | Medium | Strict scope control |

## Compatibility Strategy

1. **Migration Tool**: Automatic conversion of WLS 1.x to 2.0
2. **Compatibility Mode**: Run WLS 1.x stories unchanged
3. **Gradual Adoption**: Features can be adopted incrementally
4. **Clear Documentation**: Migration guides for each breaking change

## Community Input

WLS 2.0 scope should be validated with:
- Author surveys
- Feature voting
- Beta testing program
- Compatibility testing with existing stories

## Next Steps

1. Finalize WLS 1.1 before starting 2.0
2. Conduct author survey for feature priorities
3. Create detailed specifications for top features
4. Build prototype implementations
5. Gather feedback on breaking changes
